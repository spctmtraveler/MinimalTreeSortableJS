Here’s what’s happening and how to fix each issue:

Tree built twice → duplicate lists
At the very top of your script.js you do:

js
Copy
Edit
const root = document.getElementById('task-tree');
buildTree(sampleTasks, root);
Then, on DOMContentLoaded you clear root.innerHTML and call buildTree(...) again.
Remove that first call so you only ever build once, after you’ve loaded from the DB/localStorage.

“Task2” indent too shallow
In your addNewTask() you fall back to

js
Copy
Edit
triageChildList = document.querySelector('.task-list');
which grabs the first <ul>, often the top‐level one. You must only ever append to the TRIAGE list you located above. Remove that overly‐broad fallback (or at least guard it with “if we still haven’t found triage, bail!”).

Flags look wrong in new tasks
In addNewTask() you manually create .flag-circle elements, rather than reusing your createPriorityFlag() helper. That helper knows how to wire up the correct <button class="priority-flag"> with the right icon and styling. Switch your new‐task flags over to use that same factory.

Flag toggles don’t persist/view correctly
You broadcast a task-flag-updated event — good! But your sort of root‐level sort & your modal don’t re-read dataset.taskData. Once you fix (3) and unify flag-creation, your “sync all flags” listener will find and re-paint them correctly everywhere.

Sort button finds no sections → no sorting
In sortTasksByPriority() you do:

js
Copy
Edit
const sections = mainContainer.querySelectorAll(':scope > ul > li.section-header');
But your <ul> is a child of #task-tree, not a direct child of it, so that selector returns 0.
Change to simply:

js
Copy
Edit
const sections = document.querySelectorAll('.section-header');
so you actually loop each section.

Code changes (in script.js)
diff
Copy
Edit
@@ –3,7 +3,6 @@
//  Updated: 2025-05-12 18:30
 const debug = true;

-const root = document.getElementById('task-tree');
-buildTree(sampleTasks, root);

 document.addEventListener('DOMContentLoaded', async () => {
   // … your existing initUI() and loadTasks() code …

   // Build the task tree with the tasks we determined to use
   const root = document.getElementById('task-tree');
   root.innerHTML = '';
-  buildTree(sampleTasks, root);        // ← remove this
   buildTree(tasksToUse, root);

@@ –70,7 +69,7 @@ async function addNewTask() {
       if (!triageChildList) {
-        triageChildList = document.querySelector('.task-list');
+        // last‐ditch fallback REMOVED: we don't want to drop into the root list
         if (debug) console.log('Using first task list as fallback');
       }

@@ –230,7 +229,7 @@ async function addNewTask() {
     // Create priority flags
     const flagsContainer = document.createElement('div');
     flagsContainer.className = 'task-priority-flags';

-    ['fire','fast','flow','fear','first'].forEach(priority => {
-      // old manual .flag-circle approach…
+    // ← instead, reuse your createPriorityFlag helper so styling/behaviour is identical
+    ['fire','fast','flow','fear','first'].forEach(type => {
       const btn = createPriorityFlag(
         type,
         {
           fire:   'fa-fire',
@@ –420,7 +419,7 @@ function sortTasksByPriority() {
   // ↓ before: never finds any sections, because the selector is too narrow
-  const sections = Array.from(mainContainer.querySelectorAll(':scope > ul > li.task-item.section-header'));
+  const sections = Array.from(document.querySelectorAll('.section-header'));

   if (sections.length === 0) {
     console.warn('No sections found, aborting sort');
Remove the top‐level buildTree(sampleTasks…).

Delete that blunder‐fallback to document.querySelector('.task-list').

Switch your new‐task flag creation to createPriorityFlag(...).

Relax your sort’s section query to document.querySelectorAll('.section-header').

With those changes in place you’ll get:

No duplicates (only one tree built)

New tasks drop into TRIAGE, not the root

Flags look & behave exactly like all the others

Priority sort actually finds your A/B/C sections and re‐orders them